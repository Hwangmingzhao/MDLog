### 这里把设计模式也放到算法中

- 单例模式
  - （饿汉式）一个静态实例，一开始就实例化，私有构造方法，暴露获取实例方法
  - （懒汉式）静态实例，不初始化，私有构造，**获取实例方法 getInstance为同步方法**，先判断实例是否为空
  - 静态内部类里面有一个静态常量成员，通过静态内部类.实例可以获得这个实例
  - 使用枚举类保存对象，天然就是单例的
- 观察者模式
  - 创建一个数组保存观察者，一般为实现观察者接口的实例
  - 被观察者定义通知方法，对数组中的对象调用通知方法
  - 被观察者其他方法在业务完成后调用通知方法
    - 就好比好多个老师坐一排，同学昨晚暑假作业后就一个个通知所有老师批改
- 工厂模式
  - 简单工厂：只有一个工厂，产出一个实现了同一个接口的对象，根据输入的不同返回不同实现类的构造方法。
  - 工厂方法：多个工厂，都继承了同一个抽象工厂类，一个工厂生产一种产品，不同的工厂分别产出不同的产品，需要什么产品就new一个什么工厂
  - 抽象工厂：多个工厂，区别是一个工厂能生产多种产品
- 装饰模式：强调对原对象的增强和扩展，相似的代理模式强调对原对象的控制
- 代理模式：静态代理
-  桥接模式：是将抽象部分与它的实现部分分离 ，如果一个对象由多个维度构成，包含一个抽象类，多个对应的实体类，抽象类中由包含多个接口，通过setter可以设置不同的接口实现类
- 门面模式：由一个门面去负责外部对子系统的请求，外部请求不需要具体的去访问子系统



红黑树（HashMap用到）：重点要记住他的性质，以及查找，插入的效率都很高，是通过自平衡实现的。重要的性质有几个，重点记住红色节点的两个子结点一定是黑色的，根结点一定是黑色的。

查找的话就是二叉查找树

插入的话记住是否有叔叔结点，如果没有叔叔结点或者是黑色的，就需要进行旋转并自底向上调整。

删除爱谁谁记



B+树（mysql索引用到）：这是多叉树，每个中间结点都可能有多个数据他们代表了叶子结点的区间，只有叶子结点才保存数据，并且叶子节点是通过链表连接起来的，其优点是，**IO少，查找稳定，特别适用于范围查找**



判断有向图是否有环，可以使用拓扑排序，也就是逐渐去除入度为0的边，如果最后还有结点无法去除说明有环。



旅行商问题的回溯法求解



银行家算法（死锁避免）：将剩余资源分配给可满足的进程然后回收资源，一直做下去。







