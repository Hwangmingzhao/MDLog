### 延时消息之时间轮

比方说现在有一个需求，客户下单N分钟后未能支付便自动取消订单

有两种思路：

- 用定时任务去检查未支付的订单（缺点非常明显，想想就知道）
- 延时消息：创建订单时发送一条N分钟到期的消息

#### 延时消息

- 时间轮：数据结构是一个环形数组，数组长度表示时间轮的大小，当需要插入一个任务时，首先计算当前指针位置，加上N秒（分）并%数组长度得到存放位置，同时还需要未每个任务保存圈数，每秒或者每分钟移动一次指针，查找需要执行的任务，如果圈数为0则执行并移除，如果大于零则减一然后移动指针。



### 定时任务

- Timer
- ScheduledExecutor（本身就是一个线程池）：回想一下ThreadPoolExecutor的构造函数参数2，与其他线程池不同的是他的阻塞队列不一样。（DelayedWorkQueue），阻塞队列会自己排列任务的顺序，这个是按照执行时间排序的
- 时间轮（这个挺好用的）
- 分布式定时任务
  - xxl_job
  - elastic_job
  - light-task-scheduler



### Tomcat如何实现异步Servlet

- 在Servlet的doget方法中先获取异步上下文
- 在线程池中执行需要被异步执行的业务方法
- 最后回调异步上下文的complete方法，结束异步调用

**上面讲到Tomcat实现异步servlet,顺便看一下SpringBoot是如何通过注解实现异步调用的**

- 首先我们需要声明一个配置类并加上@EnableAsync注解，配置执行异步方法的线程池，这个类是继承了AsyncConfigurer，忘记的话请回去再看一下SpringBoot的视频，这些相当于配置文件的编写。
- 在一个需要被异步调用的方法上添加@Async注解。这个方法有可能要执行很长时间，比前端的超时时间还要长，那么你希望让他在执行完成前就返回结果给前端。
- 然后请求过来你只需要正常使用这个函数即可，它会被自动的放进线程池中运行

简单比较一下两者区别，上面的可以在返回后释放Tomcat线程，从而可以实现更大的吞吐量，但是下面的话还是会一直占用那个线程。举个例子，如果tomcat只能一次处理一个请求，而业务方法总共需要10秒，其中一个方法就需要9秒，如果使用第一种方法，那么在发出一个请求后，虽然你一秒钟后就接收到了返回值，但是后续的九秒钟你还是发不出请求，而后面那种就可以每一秒钟都接收一个请求。



### 为什么分布式要有redis

- 性能：对于频繁使用但又不经常改变的SQL，就可以把结果放在缓存中。
- 并发：如果很多并发同时访问数据库，那就会出现连接异常。此时可以利用redis作为缓冲，让请求先访问redis

**那么问题呢：**

- 缓存与数据库一致性问题
  - 如果有强一致性要求，那就不能放缓存里了
  - 降低不一致发生的概率：先更新数据库再**删**缓存
- 缓存雪崩问题
  - 缓存中的数据几乎同时失效导致所有的请求全部去数据库
  - 为失效时间加上一个随机值避免同时失效
- 缓存击穿问题
  - 何为穿透，就是不走缓存，去请求缓存中没有的数据，相当于高并发请求数据库
  - 采用互斥锁，就是你得拿到锁才能去请求数据库
  - 为主缓存做一个缓存
- 缓存并发竞争
  - 分布式锁，抢到锁的就去操作

**单线程的Redis为什么这么快**

- 内存操作
- 单线程可以减少上下文切换次数
- 非阻塞I/O多路复用

**数据类型及使用场景的优势**：

- String:最普通，但是可以做一些计算
- hash:存储结构化对象
- list: 可以做消息队列
- set: 可以做全局去重，分布式中，每个JVM在不同的地方
- zset：可以做排行榜，做延时任务（时间就是权重）

**过期策略以及内存淘汰机制**：

**定期删除和惰性删除：**定期指的是Redis每隔100ms就会去**抽查**是否有过期的key，惰性指的是，你要用的时候才去检查是否过期并删除，也就是说过期的key不一定就不存在于缓存中了，而是不能被使用了。但是问题也会很明显：不及时删掉的话就会很占内存，此时就需要内存淘汰机制。

这个可以配置，有如下几种选项：

1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。**应该没人用吧。**
2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。**推荐使用，目前项目在用这种。**
3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。**应该也没人用吧，你不删最少使用Key,去随机删。**
4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。**这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐**
5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。**依然不推荐**
6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。**不推荐**
ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致



### 如何系统地去理解和表述分布式

https://juejin.im/post/5da6b68b51882565f76606fb

两种**架构**：

SOA：面向服务的架构，子模块之间相互分离，但是需要总线去连结

MSA：微服务架构，分离更加彻底

分布式自然离不开**网络**，有几种网络工作模式

- 同步网络：全局锁，延迟有限（就是延迟能控制在一个范围内）
- 半同步网络
- 异步网络：部分算法不可行

一致性理论：

- 强一致性ACID
- 分布式一致性CAP
- 弱一致性（基本可用）

这些理论依托于在一定原则下的良好的数据结构和一致性算法



#### 分布式在不同的场景下

-  文件系统：比如HDFS  FastDFS
- 数据库：Hbase，MongoDB，ES 一般都是非关系型数据库
- 计算：Hadoop   Spark   Flink  
- 缓存： Redis 
- 消息：Kafka     RabbitMQ
- 监控：Zookeeper
- 业务:（处理业务逻辑的）：Dubbo
- 账本：bitcoin



#### 



#### Mysql主从复制原理及实现

主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；主数据库一般是准实时的业务数据库。

好处有哪些：

- 热备份数据库
- 架构扩展，提高I/O性能
- 读写分离，抗住高并发读

**原理：**使用主数据库的bin-log文件（保存了所有的sql语句），在从数据库的relay-log重做日志文件中再次执行这些mysql语句

**具体一点**：主数据库启动一个线程发送bin-log内容，从数据库启动两个线程：1.接收bin-log内容写到relay-log，2.执行写到relay-log的sql语句



### 异步回调

一个基本版的实现如下：

1. 首先A实现了回调接口，包含了一个回调方法
2. A把一项任务交给B去在另一个线程执行，调用B方法时需要同时传入一个回调接口的实现类（不用想肯定是A，因为是A叫他去做的），调用完之后这个A可以去做一些别的事情。
3. B实现完业务之后，调用传入参数中的回调接口的回调方法。

那么在实际项目中怎么做呢

- HttpServletRequest对象使用 startAsync ()可以生成一个异步容器，在容器里添加异步监听器，监听器内使用多线程方式完成业务逻辑。



### 多路复用IO

同步与异步是指的用户与系统内核交互形式。等到IO全部做完才返回就是同步，发起请求就返回是异步。那么实际上这就涉及到两个线程，也就是用户线程和系统线程，用户线程如果是阻塞的那么就是同步。那么跟我们编写服务端有什么关系呢，一个请求的信息是被封装到一个TCP报文中的，这是一个二进制流，我们收到报文后需要读取内容到机器里，这就出现了IO。

- 同步阻塞IO

  在等待内核准备数据的过程中用户线程是阻塞的

- 同步非阻塞IO

  请求后可立即返回，通过客户端轮询不停向内核请求数据，直到请求到为止

- 多路复用IO

   IO多路复用模型是建立在内核提供的多路分离函数select基础之上的 ，流程是在一个线程中可以select多个socket，然后轮询监视被select的多个socket是否可以进行IO，在同步阻塞IO中需要多线程才能完成。

  除此之外，还可以只注册感兴趣的socket，在这些socket没有数据的时候可以去做别的事情。就是将上面提到的用户线程交给Reactor处理，由Reactor去循环，当socket有消息了，就会通知用户线程去发起请求。

  ```java
  Reactor::handle_events() {
  
  while(1) {
  
  	sockets = select();
  
  	for(socket in sockets) {
  
  		get_event_handler(socket).handle_event();
  
  	}
  
  }
  
  }
  ```

- 异步IO

  在上一种模式中依然要求用户自己去发起IO请求，这一次我需要的是我要别人同时帮我监听很多个Socket，这些socket有消息之后直接给我返回我需要的数据。

   ![img](http://images.cnitblog.com/blog/405877/201411/142333511475767.png) 







































