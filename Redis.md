#### 什么是CAP定理

讲到关系型数据库mysql，我们就会想到ACID，而非关系型数据库在分布式的应用中就需要应用CAP定理

这三个字母代表三个指标，这三个指标不可能同时做到

- consistency：一致性，也就是读取不同地方的数据应该保持一致
- Availability：可用性，只要收到用户的请求就必须给出回应。
- partition tolerance: 分区容错，就是不同的服务器之间发送消息可能会失败，这是无法避免的， 也是必须在设计时需要考虑到的。

如果说P是必须存在的，也就是说，C和A必定不能同时满足，举个例子，为了保证一致性，在写数据时，必须要与其他分区进行同步，在这个过程，如果有读请求的话就不能处理了，那就是可用性不能保证。



#### Redis的持久化策略

- RDB（默认）：Redis DataBase,生成RDB文件相当于一个快照，然后写到磁盘中，需要恢复时就加载文件，获得数据对象，性能高。

- AOF：每当执行任务和函数时就会调用一次，完成写缓存到AOF文件中，并将文件保存到磁盘中，更安全也更大，还原数据时优先使用AOF。



#### 网络协议RESP

是客户端和服务端之间使用的通讯协议，简单易懂，解析快速



#### 几种架构模式

- 单机版：多个客户端连接到同一台服务器，也只有一台服务器工作

  - 内存容量邮箱
  - 处理能力有限
  - 无法高可用

- 主从复制：多个slave复制主服务器，两者数据相同，主服务器需要长期同步，在并发读时可以读取从库，写的时候向主表写，以实现读写分离

  - 无法保证高可用
  - 没有解决并发写压力

- 哨兵：为了解决主从复制不支持高可用的缺点，使用了哨兵来监控系统，在主服务器宕机后进行故障检测和故障转移，保证了高可用

  - 故障发生时，迁移数据需要耗费时间
  - 没有解决写压力

- 集群（Proxy）：多个主节点，客户端使用代理去访问服务器集群

- 集群（直连）：无中心结构，客户端连哪一个服务器都可以。无代理，直连服务器。使用slot槽分布数据，数据共享，可动态调整数据分布。

  - 资源隔离性较差，容易互相影响
  - 异步复制，不保证数据的强一致性
  
  
  
### 为什么分布式要有redis

  - 性能：对于频繁使用但又不经常改变的SQL，就可以把结果放在缓存中。
  - 并发：如果很多并发同时访问数据库，那就会出现连接异常。此时可以利用redis作为缓冲，让请求先访问redis

  **那么问题呢：**

  - 缓存与数据库一致性问题
    - 如果有强一致性要求，那就不能放缓存里了
    - 降低不一致发生的概率：先更新数据库再**删**缓存
    
  - 缓存雪崩问题
    - 缓存中的数据**几乎同时失效**导致所有的请求全部去数据库
    - 为失效时间加上一个随机值避免同时失效
    - 采用互斥锁，就是你得拿到锁才能去请求数据库
    - 为主缓存做一个缓存
    
  - 缓存穿透问题
    - 何为穿透，就是**不走缓存（绕过，有可能是故意的）**，去请求**缓存中和数据库中都没有**的数据，相当于高并发请求数据库。想一下，如果访问数据库没有返回结果，自然也就不会有缓存。
    - 对查询结果为空的情况也进行缓存
    - 参数校验（id应大于0等）
    - **布隆过滤器**
    
- 缓存击穿
  - 更像缓存雪崩，只不过是小规模的雪崩
  - 当一个key被高并发访问，如果这个key突然失效，那么就会将压力转移到数据库
  - 解决方法：使用互斥锁，或者设置热点Key为永不过期
  - 缓存并发竞争
    - 分布式锁，抢到锁的就去操作

  **单线程的Redis为什么这么快**

  - 内存操作
  - 单线程可以减少上下文切换次数
  - 非阻塞I/O多路复用

  **数据类型及使用场景的优势**：

  - String:最普通，但是可以做一些计算
    - 分布式锁
    - 保存jsonString
    - 利用自增做接口计数器（显示访问量）
    - 分布式session
- hash:存储结构化对象
    - 购物车操作
- list: 可以做消息队列
    - 实现各种线性表
  - 消息队列（微博待查看，有人发了微博那么就会往你的这个list写对应的微博ID，你上线的时候就会查出队列中的前几条给你查看）
  - set: 可以做全局去重，分布式中，每个JVM在不同的地方
  - 抽奖，可以保证同一个人不重复参加
  - zset：可以做排行榜，做延时任务（时间就是权重）
  
  **过期策略以及内存淘汰机制**：
  
  **定期删除和惰性删除：**定期指的是Redis每隔100ms就会去**抽查**是否有过期的key，惰性指的是，你要用的时候才去检查是否过期并删除，也就是说过期的key不一定就不存在于缓存中了，而是不能被使用了。但是问题也会很明显：不及时删掉的话就会很占内存，此时就需要内存淘汰机制。
  
  这个可以配置，有如下几种选项：

  1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。**应该没人用吧。**
2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。**推荐使用，目前项目在用这种。**
  3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。**应该也没人用吧，你不删最少使用Key,去随机删。**
4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。**这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐**
  5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。**依然不推荐**
6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。**不推荐**
  ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致

  
  
  #### 一致性哈希性质
  
  这是在集群中如何对数据进行分配的算法，当数据要进行存储，需要计算出其所在位置，要获得数据也要计算出其位置，就好像一个HashMap，不同的数组链表被分配到不同的数据节点中。
  
  来看一下可能会出现什么问题，如果某些节点失效，那么影响到的就不只是那些失效节点的数据，那么新到的数据要被缓存，计算的位置就跟原来不一样，在取出缓存的时候，计算某一个键的位置就不一样了（比如说取余算法），因此需要满足一下几个方面
  
- 平衡性，指的计算出来要均匀

- 单调性，指的是如果系统中有新的节点加入，原有的数据会留在原来的分区或者新加入的分区，而不是原有系统中的其他分区

- 分散性，指的是相同的内容在不同客户端hash的结果是否一致，如果分散性高，那么一个相同的内容就可能会被不同的客户端映射到不同的节点（这算不算数据冗余呢），因为不同客户端看到的节点不一定是相同的

- 负载，指的是一个位置有可能被不同的客户端缓存不同的内容

- 平滑性，是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的

  

#### 不同数据类型的应用场景

String：缓存

Hash：保存对象信息

List（实现为一个双向链表）：关注列表，粉丝列表，消息队列（栈，队列，有限集合，消息队列）利用不同的命令组合就可以实现这些功能

Set：

SortedSet：Top10

**Bloomfilter**



#### **Redis做异步队列么，你是怎么用的？有什么缺点？**

一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

缺点：

在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。

**能不能生产一次消费多次呢？**

使用pub/sub主题订阅者模式，可以实现1:N的消息队列。



#### 你为啥要使用Redis呢

- 因为传统的关系型数据库已经不能适用所有场景了，比如说瞬间的高流量，秒杀减库存问题
- 所以要用到缓存中间件，而Redis表现更好一点。



### 那你使用过Redis分布式锁么，它是什么回事？

先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放，释放锁的时候使用delete

**这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？**

这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要`抓一抓自己得脑袋，故作思考片刻`，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！



### Redis分布式锁更进一步

上面的方案实际上还有有点不足，在**分布式redis集群**中，如果对锁的要求比较高，那么就不够用了，要使用RedLock算法



#### 布隆过滤器

如果说有一个集合里面有很多不同的元素，那么当放入一个新的元素的时候如何判断它是否已经存在呢？

简单的可以通过数据库或者更快的Redis的Set，但是字符串比较起来还是比较慢，如果在不严格要求一定不重复的情况下可以使用布隆过滤器。

一个布隆过滤器由一个位数组和k个哈希函数组成，其中每个哈希函数能计算出一个index

布隆过滤器支持add和exist两种操作：

- 当添加一个元素是，会依次计算k个哈希函数的值并将位数组中对应位置1
- exist：同样计算哈希函数，如果对应的位都为1，那么就认为这个元素已经存在。如果不是所有的位都为1，那么就一定不存在。
  - 在这里可能会出现错误，不同的字符串计算出的为可能完全一样那么，认为这个元素已经存在就可能会出错。
  - 通过控制位数组的长度（越长越不容易重复）和元素容量（越大越容易在后期重复）来控制错误率

  
