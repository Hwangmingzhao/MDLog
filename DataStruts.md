### 关于HashMap

首先是底层存储，底层使用的是数组，每个元素类型是一个静态内部类Entry,这个Entry不仅保存了键值对，还保存了哈希值和下一个Entry(链地址法)。 

首先如果key不为空，那么先计算key的hashcode()，然后在通过 hash再计算一次哈希，最后通过indexfor函数计算所在数组位置。

那么存储的方式是链地址法，我们知道，这种存储办法可以快速找到我们想要的对象（前提是相对均匀而且数量不是很多），那么我们就引入了负载因子这个变量，通过负载因子和容量，我们可以计算出实际最大存储容量，如果超过了实际最大储存容量就需要扩容扩容的过程需要重新摆放对象的位置（调用resize），负载因子过大那么就装得太满查找效率降低，而且调整时间变长，反过来的话，利用率就会降低。

HashMap为什么线程不安全：

- 首先是数据的插入，重复插入会导致数据只有一条
- 扩容--->调整每个元素的位置，由于是链地址法，因此会出现死循环



ConcurrentHashMap为什么安全：

- CAS
- 锁一部分数据Segment

HashTable 锁一整张表



#### 关于循环队列

front为队头、rear为队尾、maxSize为队列的总容量、m为队列中元素的个数：

队空：front == rear

队满：(rear + 1) % maxSize = front

进队：front = (front + 1) % maxSize

出队：rear = (rear + 1) % maxSize

队列中元素的个数 m = (rear - front + maxSize) % maxSize



#### 注意线性表和线性结构是不同的



#### 关于排序是否稳定

判断依据是：在原序列中相同的两个元素，不会在排序过程中交换先后顺序。

不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序

稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序



#### DFS BFS

深度优先遍历需要使用栈

广度优先遍历需要使用队列

**深度优先需要无路可走时按照来路往回退，正好是后进先出。（栈）**

**广度优先则需要保证先访问顶点的未访问邻接点先访问，恰好就是先进先出（队列）**



#### 树的存储结构

双亲表示法

孩子表示法

孩子兄弟表示法



#### 二叉树的遍历

前中后表示父节点在左中右的位置



#### 如何能知道一棵树的结构

二叉树：先序+中序  OR   后序+中序



#### 二叉排序树（二叉查找树）

左子树都比自己小，右子树都比自己大

平衡二叉树首先是二叉排序树。基于二叉排序树，发现树越矮查找效率越高，进而发明了二叉平衡树。



