### 如何正确进行字符串的比较

当我们不确定某个不知道是否为空的字符串对象是否等于某一个指定字符串，那么不要使用该对象的equals方法，而是使用指定字符串的equals方法



#### 浮点数精度丢失

使用Bigdecimal对象，而且最好使用字符串类型作为参数的构造方法

#### 基本数据类型和包装数据类型

POJO的类属性必须使用包装数据类型，因为默认值为null，而null一般是有意义的。

局部变量使用基本数据类型。

RPC方法返回值和参数使用包装数据类型。

#### 将数组转为ArrayList

最好不要直接用用Arrays.asList方法

推荐使用List list = new ArrayList<>(Arrays.asList("a", "b", "c"))



### 数据库分区分表分库

#### 分区：

就是一百条记录按照某些规则分成若干份存储在不同的物理介质中，比如男女生分开，不同年级分开。

优点是：

1. 可保存更多数据
2. 管理方便，因为天然就是物理分类了
3. 可精准定位，比如我要找女生，那就只在某个磁盘找就行了
4. 跨分区查询，提高吞吐量。
5. 容易进行数据的合并

**水平分区**：以某一列为标准，将数据分为几个部分

**垂直分区**：将某些不常用的列分到某个分区中。

优点：使得行数据变小，减少查询时的I/O，简化表的结构

缺点：主键冗余，引起join操作，使事务变得复杂



### 如何选择索引列的顺序

建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。

- 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）
- 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）
- 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）



### 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）

- 重复索引（一个字段多次被建立索引，PK本身就是一个索引）示例：primary key(id)、index(id)、unique index(id)
- 冗余索引示例：index(a,b,c)、index(a,b)、index(a)



### 覆盖索引

当我们建立一个表的时候必须指定主键，那么这个主键就是一个索引，而且叫做聚集索引，在主键之外我们还可以针对某一个或多个属性创建索引或者联合索引，跟主键索引一样，这些索引都可以加快查询速度（合适的情况下），但是实际上运行机制是有所不同的（会使用到主键，因而又称为二级索引）

那么我们也可以绕过这个二级查询，直接从二级索引中获得我要的数据，这是一种查询的手段而不是一种索引，我们可以通过修改sql来达到覆盖索引的目的



### SQL开发规范

- 使用预编译语句
- 避免数据类型的与转换，比如说id是整型的，但是查询的时候写成了id = “11”,这样的话索引会失效，虽然能查
- 充分利用索引，减少使用前后双%
- 禁止使用 SELECT * 
- 使用in代替or
- 



### Dubbo

- 注册中心是不转发请求的
- 监控中心每分钟收集一次调用量数据用于展示
- 注册中心、服务提供者、和服务消费者之间是长连接（就是一直连接），注册中心通过长连接感知服务提供者是否在线是否宕机，如果宕机就会立刻通知服务消费者
- 在一般的使用以外还有一些值得关注的功能：
  - 隐式传参
  - 本地调用
  - 本地存根：在客户端执行部分逻辑
  - 本地伪装：伪造返回结果，可用于服务降级
  - 延迟暴露
- 设置Timeout的粒度及优先级，消费者比提供者优先![dubbo-config-override](http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-config-override.jpg)

建议由服务提供方设置超时，因为一个方法需要执行多长时间，服务提供方更清楚，如果一个消费方同时引用多个服务，就不需要关心每个服务的超时设置



### 加深一下可达性分析

1. 可达性分析

   - 将一系列GC Roots对象作为起点，从这些起点开始向下搜索，那什么可以作为GC Roots对象呢

     1.`Java`虚拟机栈（栈帧的本地变量表）中引用的对象
     2.本地方法栈 中 `JNI`引用对象
     3.方法区 中常量、类静态属性引用的对象

   - 如果一个对象不可达那就是对象不可用了，但还不足以判断对象是否存活/死亡，这些对象将会被放到“即将回收” 的集合里

2. 第一次标记 -> 筛选

   - 筛选标准：是否有必要执行finalize()方法
     - 如果finalize方法已经被调用过或者没有这个方法，那么就会等待回收
     - 如果要执行这个方法，那就筛选出来进入下一个阶段。

3. 第二次执行

   - 会专门分配一个线程给这些对象执行finalize方法，但不保证能执行完
     - 如果在这个方法中他将自身与引用链上的对象关联起来，那他就被救回来了
     - 否则就被等待回收了



### 按位与（快速取模）

在很多种需要Hash定位的算法中都会这样用到，通常用于提高性能。

由于计算机乘除法很消耗时间：对2的k次幂取模**n&((1<<k)-1)**

更多应用：

- 判断奇偶性：a&1    0:偶数  1:奇数
- 判断a是否是2的正整数幂**(!(n&(n-1)) )&& n**： 2的n次幂只有最高位为1，2的n次幂-1只有最高位为0，而上面的式子是为了加上1这个0次幂



### 一些反射相关

首先回顾一下反射，就是通过一个类本身去活得它的实例及方法，然后你可以对这个反射回来的镜像。我们一般的目的就是为了调用方法嘛

**对于方法列表的获取：**

getMethod是所有的公有方法（列表），包括从父类继承过来的

getDeclaredMethod是这个类自己声明的方法（列表） 

Class 中会维护一个 ReflectionData 的软引用，作为反射数据的缓存，保存了方法列表和成员列表之类的。

**获取方法：**

通过Method的copy方法返回方法的一个拷贝。

**调用方法**：

使用什么样的方式去调用这些方法，取决于使用哪种**MethodAccessor**

分别有：

**MethodAccessorImpl** 是通过动态生成字节码来进行方法调用的，是 Java 版本的 MethodAccessor

**DelegatingMethodAccessorImpl** 就是单纯的代理，真正的实现还是 NativeMethodAccessorImpl。

**NativeMethodAccessorImpl** 是 Native 版本的 MethodAccessor 实现。（性能较低但是加载的资源较少，如果调用次数较多，就可以转为使用第一种实现）

#### 为什么反射效率会低下呢

1. 调用方法时会对方法参数做封装和解封
2. 需要检查方法可见性
3. 需要校验参数
4. 难以内联



## 1、获取Class对象的三种方式

### 1.1   getClass(); 

### 1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性 

### 1.3 通过Class类的静态方法：forName（String  className）(常用)