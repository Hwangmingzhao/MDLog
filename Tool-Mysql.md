查询：

1. 可使用数学表达式

   ```sql
   select sal*12 as yearsal form t
   ```

2. 条件查询的运算符

   - between ... and ...   等价于  >=  and <=
   - is null 不能用= null
   - and 
   - or   如果和and并列使用，则and的优先级更高，使用括号可以解决
   - in   相当于多个or
   - like  模糊查询 %多个字符 _一个字符  [charlist]  字符列中的任何单一字符  [!charlist]  不在字符列中的任何单一字符 

3. order by 排序字段1，排序字段2 

   - 默认升序asc   
   - 如果有where 必须放在where语句后面，先过滤再排序
   - 多个排序字段时，优先排序前者，若前者相同则按照后者排序，依次向后。

4. 插入

   ```sql
   INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)
   ```

5. 更新

   ```sql
   UPDATE 表名称 SET 列名称 = 新值,列名称 = 新值  WHERE 列名称 = 某值
   ```

6. 只选择其中几条

   ```sql
   SELECT column_name(s)
   FROM table_name
   LIMIT number
   ```

7. 几种JOIN

   1. Inner join :`From 主表 JOIN 从表 ON 主表.属性 = 从表.属性 ` 

   2. Left join:`From 主表 Left JOIN 从表 ON 主表.属性 = 从表.属性`主表所有行都会列出来

   3. Full join:`From 主表 Full JOIN 从表 ON 主表.属性 = 从表.属性`如果匹配的话就会列出完整数据，否则都只列出部分数据.

      - 由于Mysql不支持full join，所以可以使用union将几个部分结合起来

      ![img](https://images2018.cnblogs.com/blog/706569/201806/706569-20180621110545977-2083791147.png)

   4. 如果想要实现从主表中剔除主表与从表的交集的话，可以在left join的基础上再`where 从表.id is null`

8. UNION :请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。

   ```sql
   SELECT column_name(s) FROM table_name1
   UNION
   SELECT column_name(s) FROM table_name2
   ```

9. SELECT INTO：从一个表中选取数据，然后把数据插入另一个表中。

   ```sql
   SELECT LastName,FirstName
   INTO Persons_backup
   FROM Persons
   WHERE City='Beijing';
   
   
   SELECT Persons.LastName,Orders.OrderNo
   INTO Persons_Order_Backup
   FROM Persons
   INNER JOIN Orders
   ON Persons.Id_P=Orders.Id_P;
   ```

10. 几种约束

    1. not null

    2. unique  

    3. primary key

       **UNIQUE 和 PRIMARY KEY** 约束均为列或列集合提供了**唯一性**的保证。

       PRIMARY KEY 拥有**自动定义的 UNIQUE 约束**。

       请注意，每个表可以有**多个 UNIQUE** 约束，但是每个表只能有**一个 PRIMARY KEY** 约束。

    4. foreign key: 

        一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY

       FOREIGN KEY 约束用于预防破坏表之间连接的动作。

       FOREIGN KEY 约束也能**防止非法数据插入外键列**，因为它必须是它指向的那个表中的值之一。比如一个商品记录对应的用户ID必须在用户表中存在。

       ```mysql
       CREATE TABLE Orders
       (
       Id_O int NOT NULL,
       OrderNo int NOT NULL,
       Id_P int,
       PRIMARY KEY (Id_O),
       FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)//关联到另一个表的主键
       )
       
       //添加外键
       ALTER TABLE Orders
       ADD FOREIGN KEY (Id_P)
       REFERENCES Persons(Id_P)
       
       //撤销外键依赖，而不是删除对应的列
       ALTER TABLE Orders
       DROP FOREIGN KEY fk_PerOrders
       ```

       

    5. check

       ```mysql
       CREATE TABLE Persons
       (
       Id_P int NOT NULL,
       LastName varchar(255) NOT NULL,
       FirstName varchar(255),
       Address varchar(255),
       City varchar(255),
       CHECK (Id_P>0)     //规定只能大于10
       //另一种方法
       CONSTRAINT chk_Person CHECK (Id_P>0 AND City='Sandnes')
       )
       
       
       //添加check依赖
       ALTER TABLE Persons
       ADD CHECK (Id_P>0)
       
       ALTER TABLE Persons
       ADD CONSTRAINT chk_Person CHECK (Id_P>0 AND City='Sandnes')
       
       
       ```

    6. default ：插入默认值

       ```mysql
       CREATE TABLE Orders
       (
       Id_O int NOT NULL,
       OrderNo int NOT NULL,
       Id_P int,
       OrderDate date DEFAULT GETDATE()
       )
       
       //注意不是增加依赖，而是设置
       ALTER TABLE Persons
       ALTER City SET DEFAULT 'SANDNES'
       
       ALTER TABLE Persons
       ALTER City DROP DEFAULT
       
       ```

11. INDEX  **在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。**用户无法看到索引，它们只能被用来加速搜索/查询。

    ```mysql
    CREATE INDEX index_name
    ON table_name (column_name)//需要指定在哪一列上
    ```

12. AlTER Table  在已有的表中添加修改和删除列，还可以修改列的属性，操作索引以及约束等等。

    1. DROP  字段/ 默认值/ 索引/约束
    2. ADD
    3. MODIFY  字段名 类型
    4. CHANGE 旧字段名 新字段名 类型
    5. SET default
    6. RENAME TO

    ```ms
    CREATE VIEW view_name AS
    SELECT column_name(s)
    FROM table_name
    WHERE condition
    
    //使用
    SELECT * FROM [Current Product List]
    ```

13. Having:   在 SQL 中增加 HAVING 子句原因是，**WHERE 关键字无法与合计函数一起使用。**

    ```mysql
    SELECT Customer,SUM(OrderPrice) FROM Orders
    WHERE Customer='Bush' OR Customer='Adams'
    GROUP BY Customer
    HAVING SUM(OrderPrice)>1500
    
    // SUM(OrderPrice)>1500这个条件不能写在where中
    ```

14. 一些函数

    1. MID(City,1,3)
    2. LEN(column_name)

15. delete 删除数据  如果想全部数据删除，可以不带where或者使用trunacate

16. DROP 表名 直接删表啥都没了

17. TEMPORARY 创建临时表，只在当前会话存在，show tables看不到

18. 如果想复制一个表，那么首先使用 show create table 表名 获取建表语句然后使用在新表中插入数据



### MySql的逻辑框架

- 连接层
- 服务层
- 引擎层（可更换）
- 存储层

语句的执行过程：

![img](https://images2018.cnblogs.com/blog/706569/201806/706569-20180621095336251-966027615.png)



#### 关于索引

- 简单可理解为排好序的快速查找数据结构

- 优点：提高检索效率，降低IO成本

- 通过索引列对数据进行排序，降低数据的排序成本，降低cpu的消耗。

- 其加速原理是：如果你有多个数据，并且他们数据一般不会重复，那么你在这一列上创建索引，他就会建立一个索引表（如果数据很多那么这个时间会很长），类似于对这部分数据做一些处理使其很容易就定位到某一个数据（其实用的是B+树）。

- 需建立索引的情况

  1.主键自动建立唯一索引。

  2.频繁作为查询条件的字段。

  3.查询中与其他表关联的字段，外键关系建立索引。

  4.高并发下趋向创建组合索引。

  5.查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。

  6.查询中统计或分组字段。

- 不需要创建索引的情况

  1.表记录太少。（数据量太少MySQL自己就可以搞定了）

  2.经常增删改的表。

  3.数据重复且平均分配的字段，如国籍、性别，不适合创建索引。

  4.频繁更新的字段不适合建立索引。

  5.Where条件里用不到的字段不创建索引。

- 最左前缀原理：帮助我们理解到底这次的查询是否使用到了联合索引。

  - 比如说我建立了三个索引对应属性a,b,c  我在查询时使用了这三个属性进行了精准匹配（in或者 =）,那么就会使用到三个索引
  - 如果我只使用了a,c属性进行查找，那么a对应的索引被我使用上了，但c的索引没用上，因为没有用到b
  - 范围右边的索引列失效，如果使用了 a,b,c，但是b是范围查找，即b>100，那么c也会失效。
  - 最左前列（带头大哥）的索引失效，则后面的索引都失效。

- 注意：添加主键，添加Unique约束也相当于创建了索引。

- **在索引列上做任何操作，都会导致索引失效转向全表扫描，比如你修改了当列中某个数据的数据类型。**

- **!=会使type=ALL，key=Null，导致全表扫描，并且索引失效。**

- **like查询为范围查询，%出现在左边，则索引失效。%出现在右边索引未失效。**

  **解决%出现在左边索引失效的方法：使用覆盖索引，就是你的索引在name这一列，你查询的时候也要查他。**
  
- **or会导致索引失效**。

- 索引不止影响查询还会影响排序，并且底层不会优化顺序，要与创建顺序相同不然后果非常严重。

- 关于**索引和排序**的关系

  > https://www.cnblogs.com/developer_chan/p/9225638.html



#### Explain（执行计划）

- id： 表示查询中执行Select或操作表的顺序，结合table列分析。子查询中，id会递增，值越大优先级越高。
- select_type 查询类型
- table
- patitions
- type 访问类型，不同的类型表示查询的好坏。
- possible_keys和key、key_len
- ref
- rows
- filterd
- Extra
  - Using filesort 使用了外部索引排序，需要优化
  - Using temporary  使用了临时表保存中间结果，常见于排序order by和分组查询group by。非常危险，“十死无生”，急需优化。
  - Using index :可以





####   ANSI SQL语句分成以下六类（按使用频率排列）： 

**数据查询语言（DQL**）：其语句，也称为“数据检索语句”，用以从表中获得数据，确定数据怎样在应用程序给出。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有WHERE，ORDER BY，GROUP BY和HAVING。这些DQL保留字常与其他类型的SQL语句一起使用。  

**数据操作语言（DML）**:其语句包括动词INSERT，UPDATE和DELETE。它们分别用于添加，修改和删除表中的行。也称为动作查询语言。  

**事务处理语言（TPL）**：它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。  

**数据控制语言（DCL）**：它的语句通过GRANT或REVOKE获得许可，确定单个用户和用户组对数据库对象的访问。某些RDBMS可用GRANT或REVOKE控制对表单个列的访问。  

**数据定义语言（DDL）**:其语句可在数据库中创建新表（CREAT TABLE）；为表加入索引等。DDL包括许多与人数据库目录中获得数据有关的保留字。它也是动作查询的一部分。  

**指针控制语言（CCL）**：它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。    





#### 慢查询：超过指定时间的SQL语句称为慢查询

开启慢查询日志记录：如果有语句查询时间过长，那么就会记录在日志中。





### 事务

使用start transaction开启一个事务，只要事务没有commit,那就可以rollback到上一次commit的状态，如果你要插入数据，而属性是自增主键的，那么回滚后再次插入自增主键将会从上一次回滚的最后一条记录之后开始自增。

四个隔离级别：一般是多个事务同时执行。

设置事务全局隔离级别：

`set global transaction isolation level 对应的隔离级别` 

- uncommitted   读未提交（能够读到未提交的数据）不能防止那三个问题。
- read committed  读提交（只有提交的东西才能读出来），能防止脏读
- repeatable read  可重复读，能防止不可重复读，就是说在你自己的事务中，无论你读多少次都是一样的，别的事务就算提交了，你也看不到，直到你开启了下一次事务。
-  serializable :序列化（串行化） ，就是说你的事务如果有在修改但是没有提交，别的事务会被你堵塞，直到你commit，这就是串行化的由来，只能有一个事务在操作





### 数据库设计三范式

按照这个三范式设计的表不会出现数据冗余

- 第一范式：每个表都要有主键，而且每个属性不可以原子再分，也就是说你不可以吧电话和住址放到一起，而是分开，知道他们的意义独立，原子了。
- 第二范式在第一范式基础之上，要求所有非主键字段完全依赖主键，不能产生部分依赖。首先我们要明确一个点就是，主键可以是联合主键，比如学生id跟教师id可以联合起来成为主键（唯一），但是一个学生的姓名对于这个联合主键来说只有学生id就可以区分开了。换句话说，如果你的联合主键的一部分就足够划分某个或者多个属性了，那么就不满足第二范式，应该拆开。
  - **多对多？三张表，关系表里有两个外键**
- 第三范式，在第二范式基础上，所有非主键字段直接依赖主键，不能产生传递依赖。就是说一个属性不能单独另外一个非主键的属性
  - **一对多？两张表，多的一方一个外键。**
- 在实际开发中，有时候会用冗余换速度。减少join的资源消耗

**一对一怎么设计**：

有时候一个人的信息会有很多，但是在某些功能上对某一个属性的访问很多次，可以考虑把这个部分拆出来（同一个主键）。然后把**主表**的主键设为外键。或者在主表加一个外键然后加上unique约束。





### 锁

#### 表锁：锁住一个表

- 读锁
  - 如果一个会话A对一个表上了读锁，不影响其他会话读取这个表。
  - 未解锁的话，谁都不能向这个表写入内容
  - 未解锁的话，A不能去读别的表
- 写锁
  - 如果一个会话A对一个表上了写锁，A可以同时读写这个表。
  - 在解锁前，A不能操作别的表。
  - 别的会话也不能对这个表进行操作。

#### 行锁：锁一行 要求存储引擎为Innodb

做法：

1. 关闭自动提交（开启事务）
2. 在查找条件上创建索引

- 如果A修改了谋一行数据担忧未提交，此时B也修改这一行数据的话，就会被阻塞。（因为有行锁的存在）
- 如果A更新某一行时使用where但数据类型搞错了，那么就会导致**索引失效**，这样会导致行锁升级为表锁，这时候B向哪一行更新都会被阻塞。
- **间隙锁**：如果使用范围查找，在确定范围中你也不能插入数据。比如主键分别为1、3、4、5、6、7、9，这就是一个索引，如果你的范围确定在>=1 and <=6的话，如果B会话想要往这个范围内插入或者修改数据就会被阻塞，即便B要插入2。但是插入8是没有问题的因为不在这个范围内。
- 在InnoDB中，行锁的能力跟事务隔离级别有关，如果想要让锁对你的性能降低少一点，可以考虑降低事务的隔离级别。



### 存储过程

优点：

- 通信开销小，已通过编译，执行快。
- 可多次调用
- 增强功能和灵活性

缺点：

- 比较难维护
- 可移植性差

什么时候考虑用存储过程呢，当一个事务涉及多个SQL或者对多个表的时候可以考虑，将逻辑控制交给它自己去完成，但是这会降低系统的可移植性。



创建存储过程的步骤：

- 选定一个数据库

- 先临时改变改变结束符符一般为$$，不要让分号作为执行结束的标记`delimiter $$`,这是为了在传递这些“代码”上去的时候不要被解释

  ```mysql
  #创建一个存储过程
  create procedure hello(IN p_stu_no INTEGER)
  begin
   selete * from student where student_no = p_stu_no
   ...
  end$$
  
  #创建完成后还要把结束符改回来
  delimeter ;
  
  set @p_in=1
  
  call hello(@p_in)
  ```

  - 存储过程体：
  - 以begin开始，以end结束，可以嵌套
  - 每条语句除了begin和end都需要以分号结束
  - 存储过程体包含DML，DDL，逻辑判断，变量声明
    - 局部变量的作用域再一个begin和end内
    - 条件语句：**if 开始 end if;结束**
    - case:   case 变量 开始，**when ? then** 中间，end case结束
    - while ：**while 条件 do**开始 ，end while结束
    - do-while：repeat 开始，**until 条件**中间，end repeat结束
    - 单纯的循环： 相当于没有语法上限制你的条件，自己记得要leave(break)， **LOOP_LABLE:标志** 开始，中间要判断是否结束，**end 标志** 结束

- `call hello`   没有参数的调用

**局部变量：** 

定义：declare 变量名 数据类型（Mysql的数据类型） default 默认值

赋值：set 变量名=值

**参数：**

1. 输入参数，可以是字面量也可以是这个值不能被返回，调用结束后，实参不会被改变,只能在存储过程内部改变这个值

   function(in para_name type)

2. 传出参数，即便是调用过程前被赋值了，但在**传入函数时值变为空**，可在内部改变，并可以返回，调用结束后，实参（外部）被改变。相当于新建一个内部变量然后结束之后再绑定到外部参数中

   function(out para_name type)

3. 输入输出参数：在过程调用之后，还是保持传入时的值，相当于传入引用。

   function(inout para_name type)







## 高性能MYSQL

#### mysql的架构：

​	最上层是连接层以及线程处理，这并不是mysql的核心，第二层是核心，包含查询解析，分析，优化和缓存以及一些函数，所有的跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等，第三层是存储引擎，负责数据的存储和提取。服务器通过一系列API与存储引擎通信，存储引擎间会有差异。

 	每个客户端**连接**都会在服务器中拥有一个线程，每个连接的查询只会在单独的线程中执行。在mysql5.5之后的版本中，开始支持线程池，可以使用少量线程来服务大量的连接

​	**优化与执行**，mysql会解析我们的查询，并创建数据结构and进行优化。优化器并不关心用的是什么存储引擎，但是优化的过程中需要存储引擎提供一些特定信息。



​	**并发控制**，为了在锁的开销和数据的安全性之间寻求平衡，大多数商用数据库系统使用的是行级锁，而Mysql提供了多种选择：表锁（基本，Mysql服务器会使用）、行级锁（InnoDB,只在存储引擎层实现）



​	**事务**：基本的概念已经熟悉了，在mysql中，默认是Autocommit，即一条命令就是一个事务，另外，一些命令在**执行前会强制commit当前活动的事务**

​	

​	**MVCC**，多版本并发控制，即便是使用了行级锁，锁的开销依然不能忽略，所以大多数存储引擎都会有MVCC以提高性能，主要是通过存储隐藏的两个列来实现。



​	**存储引擎**，每一个数据库就是一个目录，每一张表创建的时候都会在对应的目录下创建一个 表名.frm 用于保存表的信息，其中包含一些信息，可以通过SHOW TABLE STATUS LIKE 'table_name' 来展示

- Max_data_length 表数据的最大容量

- Index_length 索引的大小

  等等…



#### Schema与数据类型优化

1. 选择优化的数据类型：
   1. 更小，预估数据范围
   2. 简单，比如整型比字符型好，比如使用整型存储IP
   3. 尽量避免NULL（尤其是索引的列），因为更难优化
2. 有一些数据类型只是一些基本数据类型的别名
3. 不同的数据类型
   1. 整数：TINYINT  SMALLINT  MEDIUMINT INT BIGINT  
   2. 实数：DECIMAL（可进行精确运算） DOUBLE  FLOAT
   3. 字符串： CHAR VARCHAR
   4. 大文本：BLOB TEXT
   5. 时间：DATETIME TIMESTAMP、
4. 设计表时的陷阱
   1. 太多的列
   2. 太多的关联
   3. 过度使用枚举
   4.  不要太在意刻意不去使用NULL
5. 范式的优点和缺点：
   1. 优点是数据冗余小，查找快
   2. 缺点是需要比较多的关联查询
   3. 讲道理，范式并不是我们设计表的规范，而是一切都要从实际业务出发，也不一定需要做到遵循范式或者将两个表合到一起，可以存储一些冗余数据，也可以使用缓存表。
   4. **缓存表**的概念：表示存储那些可以比较简单地从其他表中获取但速度又比较慢的数据
   5. **汇总表**的概念：存储那些GROUP BY语句的结果
   6. **计数器表**是个很简单但又很有效的东西
      1. 讲一下怎么用，最简单的方法就是只有一行数据，每次更新这一行，但是问题是会有锁占用(行级锁进化，表锁)，对于高并发就会比较慢
      2. 为了解决上面的问题：我们可以创建一个100行的表，每次更新就随机选择其中一行加一，要统计的话就SUM，perfect!
6. ALTER TABLE 对性能是一个考验，某些情况下可以通过修改frm文件来达到相同的目的，尽管这样的情况很少。

​	

#### 高性能索引

索引的优点和缺点：

- 优点：加快查询速度，提高IO性能
- 缺点：创建索引以及维护索引要耗费时间，也需要占用空间，降低了写入数据的速度

1. 首先，索引是在存储引擎层的，在不同的存储引擎中工作方式并不一样

2. 不同的索引类型

   1. B-Tree(实际上是B+树) 什么查询可以使用到使用了B-Tree的多列索引呢（看前面，索引是否失效）
      1. 全匹配
      2. 最左前缀、
      3. 匹配列前缀，某一列的前缀（后缀不行）
      4. 匹配范围
   2. Hash索引，只有精确匹配所有列才会生效
      1. 问题很明显，无法进行范围查找，无法排序，hash碰撞问题
   3. 空间数据索引
   4. 全文索引

3. **高性能索引策略**

   1. 对于大文本可以只索引一定数量的前缀，首先要找到选择度较高的前缀长度 然后 KEY (city(N))

   2. 如果我们知道索引生成的数据结构我们就会知道多个单列索引往往性能上没有多列索引好，而且很有可能会没办法都使用到，在现行mysql版本中会针对单列索引进行优化（也就是尝试多使用几个单列索引），有三种策略：

      1. OR条件下是将结果集联合
      2. AND条件下是将结果相交，如果这样的情况大量发生，就需要进行索引的合并
      3. 1 2结合

   3. **多列索引选择合适的索引列顺序**

      1. 如果你只是用于使用WHERE来进行查询，那么将**选择度高的放在前面**是个不错的选择，而不是执着于按照查询条件的顺序，同时跟你的查询条件的具体值的分布也相关（基于业务）

   4. 聚簇索引与非聚簇索引（称为二级索引）

      1. 聚簇索引一张表只能有一个（一般就是主键），因为表的数据就是根据索引的顺序来存储的，如果你使用了索引，那么就能直接找到对应的数据（这对于范围搜索特别有效，因为物理存储就是连续的）
      2. 二级索引从名字可以看出，要找到数据行需要两次查找，二级索引就是主键，这是隐含的，我们定义一个索引（A B），其实相当于（A B ID），因为实际上找到的是主键值然后定位到数据行。
      3. 用一个例子表示就是我们的汉语字典：聚簇索引就是我们的拼音，实际我们的汉字也是按照这个顺序来排列的
      4. 使用与业务无关的值作为主键最好使用**自增主键而不要用UUID**，这样是为了保证插入数据时是从尾部顺序插入而不需要移动其他行。
      5. 顺序主键也会有问题，在高并发插入时会在表的末尾发生争用

      **建立聚簇索引的思想**

      > 1、大多数表都应该有聚簇索引或使用分区来降低对表尾页的竞争，在一个高[事务](http://baike.baidu.com/view/121511.htm)的环境中，对最后一页的封锁严重影响系统的吞吐量。
      >
      > 2、在聚簇索引下，数据在物理上按顺序排在数据页上，重复值也排在一起，因而在那些包含范围检查 (between、<、<=、>、>=)或使用group by或orderby的查询时，一旦找到具有范围中第一个键值的行，具有后续索引值的行保证物理上毗连在一起而不必进一步搜索，避免了大范围扫描，可以大 大提高查询速度。
      >
      > 3、在一个频繁发生插入操作的表上建立聚簇索引时，不要建在具有单调上升值的列(如IDENTITY)上，否则会经常引起封锁冲突。
      >
      > 4、在聚簇索引中不要包含经常修改的列，因为码值修改后，数据行必须移动到新的位置。
      >
      > 5、选择聚簇索引应基于where子句和连接操作的类型

   5. **覆盖索引**：如果说一个索引包含所有**需要查询的字段**的值，我们就称之（这个索引）为覆盖索引，能够**极大**提升性能(因为减少了二次查找)，简单来说就是select 的字段是索引字段的子集，Extra中显示Using index才是正确的，如果你的where条件（且满足最左前缀这些原则）是索引的子集，那么会显示Using where

   6. 排序的两种方法：排序算法 或者按索引顺序扫描(依然需要满足最左前缀)，后者Explain的结果中type值是index，

      1. 只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向(默认正序)都一样时，才能使用按索引顺序排序。如果WHERE是 = 的话，这个条件可以跟order by 的条件组合成最左前缀，否则要从order by的条件开始计算。

      2. 如果联表查询然后排序的话，那么排序字段必须全部来自第一个表才可以使用索引排序（依然要满足最左前缀）

   7. **重复索引**就是一个列建立了多个相同类型的索引，我们的主键constraint和Unique constraint都是通过索引实现的。**冗余索引**指的是已经有了索引（A B C）但是建立了（A B） 或（A），因为第一个索引完全可以满足后面两个的功能。冗余索引还有一种情况是在已有的索引后面加上主键，这是没有必要的。但是要注意，**索引变长会增加insert和update的时间**。

      >  **（1）InnoDB的主键采用聚簇索引存储，使用的是B+Tree作为索引结构，但是叶子节点存储的是索引值和数据本身（注意和MyISAM的不同）。**
      > **（2）InnoDB的二级索引不使用聚蔟索引，叶子节点存储的是KEY字段加主键值。因此，通过二级索引查询首先查到是主键值，然后InnoDB再根据查到的主键值通过主键索引找到相应的数据块。** 
   

   
   
   
#### 查询性能优化

   1. 优化数据访问：对于性能低下的查询，我们需要注意：是否有可能**检索**了大量超过需要的数据，即访问了过多的行，是否有可能MySQL服务器在**分析**大量超过需要的数据行
      1. 是否请求了不需要的数据：包括行和列
         1. 使用LIMIT选出所需要的数据范围
         2. 在多表关联查询中，你只想要其中一张表的信息，但是你用了 select * 的话就会将多表union的所有列返回，因此要确定
         
         **扩展：多表联合的顺序**
         
         - 驱动表：指第一个被处理的表，使用这个表的记录去关联其他表，优先选择结果集最小的那张表作为驱动，Explain中第一行的就是驱动表from 
         
      2. 是否扫描额外的记录：可以1查看扫描的行数和返回的行数。
      
      3. 访问类型：EXPLAIN 中的**type**列（由上至下逐渐变差）
         1. const: 查找主键索引，因为一个主键值对应一个或零个数据行，属于精确查找。
         2. ref_eq: 他知道这个数据肯定只有一行，有点类似const（比较少见）
         3. ref：使用了索引而且不是主键或者unique key, 虽然通过索引找到了某个值，但是这个值并不唯一，还要往后找数据行，因为是小范围的所以性能很不错
      4. range：带有范围的索引扫描，也就是说不是扫描所有索引了，如果你的where 条件中有between or in 等就是范围索引扫描
         5. index：不要看到index就觉得很快了，其实只是另一种形式的全表扫描，按照索引顺序的扫描，即先去读索引然后再去回表中随机读数据。 在**覆盖索引**（Extra为Using Index）以及**按照索引排序**情况下性能会提高
         6. all: 全表扫描
         
      4. EXPLAIN 中的**extra**列（重要的）：
         1. Using filesort：使用排序算法进行排序，超慢
         2. Using index ：覆盖索引
         3. Using where: 在mysql服务层对结果进行过滤
         
      5. WHERE是的三种工作原理：
      
         1. **索引中过滤**（存储引擎层完成），然后去找数据行，返回。
         2. 索引覆盖后，返回数据到mysql服务层，然后在**服务层过滤**
         3. 从数据表中获得数据，在**服务层过滤**
      



#### 一些简单的sql优化手段

1. 不要select *
2. 减少子查询，用关联查询
3. 不要用IN或NOT IN
4. where子句最好不要用 != 或 <>
5. 避免在where 子句中判断null
6. 索引的优化
   1. 最左前缀
   2. 排序 匹配 group by可以建索引
   3. 索引列不参与计算
   4. 对大文本创前缀索引
   5. 尽量扩展索引而不是新建索引
   6. like不要使用%xxx%



#### 索引的分类

普通索引：index key

唯一索引：unique key 

主键索引：primary key，与唯一索引的区别是不可以为null，而且一个表只能有一个

组合索引：

全文索引： fulltext(col)



#### 索引何时失效或者说不完全走索引的情况

对于组合索引，重要的就是最左前缀原则，范围查找后的列就算在索引中也不会用，只有=或in才能继续使用后面的索引。

- like前缀没有%  后缀有%有效
-  只有当or左右查询字段均为索引时，才会生效。 
- 组合索引第一列都没有用
- 数据类型发生转换
- 在 索引列上使用 IS NULL 或 IS NOT NULL操作 ，因为索引不索引空值
-  在索引字段上使用not，<>，!= 
- 计算
- 函数
- 如果全表扫描更快








