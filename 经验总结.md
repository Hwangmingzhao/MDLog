### 如何解析Json数据

1. 首先我们将Json字符串转换为JSON对象
2. 我们使用一个List<Map<String, Object>>来接收数据，即将树状的JSON数据转换为Excel这样的二维表

```java
// 我们定义下面的数据结构用来表示树的每一个节点
public class DataNode {

    private Boolean isRoot;
    private Boolean isEmptyNode = true;
    private Boolean isLeaf = false;
    private Boolean isArray = false;
    private DataNode parent;
    private List<DataNode> children = Lists.newArrayList();
    private String key;
    private Object value;
    // 中间的一些关键方法先忽略
}
```

3. 接下来我们要从根节点开始，构建整棵树出来。

```java
// 1. 创建一个根节点 根节点不包含任何值
public static DataNode createDataTree() {
    return new DataNode(true);
}
// 2. 传入根节点，进行解析
private static void visitTree(Object currentNode, DataNode dataTree, String parentPath) {
    	// 如果该节点为空则直接返回
        if (currentNode == null) {
            return;
        }
        if (currentNode instanceof JSONObject) {
            // 如果当前节点是一个对象，遍历所有键值对
            for (String objKey : ((JSONObject) currentNode).keySet()) {
                Object obj = ((JSONObject) currentNode).get(objKey);
                // 生成子节点的路径
                String currentPath = StringUtils.isBlank(parentPath) ? objKey : parentPath + "." + objKey;
                // 如果没到叶子节点，则递归调用向下走
                if (obj instanceof JSONArray) {
                    visitTree(obj, dataTree.newEmptyChild(objKey, true), currentPath);
                } else if (obj instanceof JSONObject) {
                    visitTree(obj, dataTree.newEmptyChild(objKey, false), currentPath);
                } else {
                    // 如果这个节点是一个最终值，那么这个节点就是一个叶子节点，并关联到父节点上
                    DataNode targetNode = dataTree.newChild(currentPath, ((JSONObject) currentNode).get(objKey));
                    targetNode.setLeaf(true);
                }
            }
        } else if (currentNode instanceof JSONArray) {
            for (Object obj : ((JSONArray) currentNode)) {
                // 数组内可能有三种情况，普通的值，json对象，json数组
                if(!(obj instanceof JSONArray) && ! (obj instanceof JSONObject)){
                    // 如果是普通的值，那么会循环创建叶子节点并关联到父节点中，但不需要新创建路径，因为对于数组来说，这些值不是子值。
                    DataNode targetNode = dataTree.newChild(parentPath, obj);
                    targetNode.setLeaf(true);
                    continue;
                }
                Boolean isArray = (obj instanceof JSONArray);
                // 如果是对象或者数组，向下创建的子节点都不需要key，因为对于数组来说，所有的元素都没有自己的key
                visitTree(obj, dataTree.newEmptyChild("", isArray), parentPath);
            }
        }
    }
```

4. 解析树结构并生成二维表

```java
private static List<Map<String, Object>> getResultList(DataNode dataTree, List<Map<String, Object>> dataSet) {
    	// 首次需要初始化数据容器
        if (dataSet == null) {
            dataSet = Lists.newArrayList();
            Map<String, Object> initRecord = Maps.newHashMap();
            dataSet.add(initRecord);
        }
		// 如果该节点是叶子节点，那么会向所有数据行添加这一个字段
        if (!dataTree.getEmptyNode()) {
            for (Map<String, Object> record : dataSet) {
                record.put(dataTree.getKey(), dataTree.getValue());
            }
        }
		// 如果该节点是一个数组，那么向上的这些数据行应该公平地享有这个数组中的各个平行的值
    	// 体现在对数组中每一个元素，都会复制一份已有的数据行给他，然后每个元素再向下以这一份副本生成二维表
        if (dataTree.getArray()) {
            List<Map<String, Object>> mergedDataSet = Lists.newArrayList();
            for (DataNode dataNodeChild : dataTree.getChildren()) {
                List<Map<String, Object>> dataSetForChild = copyDataSet(dataSet);
                dataSetForChild = getResultList(dataNodeChild, dataSetForChild);
                // 子元素生成自己的数据集后，需要合并
                mergedDataSet = mergeDataSet(mergedDataSet, dataSetForChild);
            }
            dataSet = mergedDataSet;
        } else {
            if (dataTree.getChildren() != null && !dataTree.getChildren().isEmpty()) {
                for (DataNode dataNode : dataTree.getChildren()) {
                    dataSet = getResultList(dataNode, dataSet);
                }
            }
        }
        return dataSet;
    }
```





### AOP如何实现翻译

目的，将业务接口的所有的形如datasource-xxxxx替换为当前语言环境下的该词条，如果用AOP来做，我立马就可以想到，定义切面-》定义行为，那么具体应该怎么做

1. 定义切面：我们的接口入口都是从XXXServiceDelegateImpl进来的，而且都是通过实现自动生成的XXXServiceDelegate接口的方法，第一个参数固定为context，根据这两个特点，我们定义切面的表达式为`bean(*ServiceDelegateImpl) && args(context, ..)`，这样的话我们能保证所有接口的返回都能被处理，但是不能保证非接口不会被处理。

2. 定义行为，首先我们要考虑一下应该使用@Around还是@After注解，直觉告诉我应该选择@After，但是如果我们要保证我们返回的对象跟方法原先返回的对象是同一个类型，我们就需要在转成字符串并翻译过后，再转换成原来的返回对象并返回，那么我们就需要获取返回类型，下面是伪代码

   ```shell
   1. JoinPoint.getSignature.getReturnType
   2. context.getLocale
   3. JoinPoint.proceed
   4. result.ParseString
   5. resultStr.translate(locale)
   6. resultStr.parseObject(returnType)
   ```

3. 如何翻译呢：我们这里可以利用Spring提供的MessageSource接口，很方便地完成翻译,按照这个Bean地规则，我们在对应地路径下添加不同语言的Properties文件

   ```xml
   <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
           <property name="basename" value="I18nForPresetData.Resources"/>
           <property name="useCodeAsDefaultMessage" value="true"/>翻译不了不会抛异常而是返回原字符串
           <property name="defaultEncoding" value="UTF-8"/>
           <property name="cacheSeconds" value="60"/>
       </bean>
   ```




