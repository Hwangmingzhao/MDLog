## Java表达式引擎



在计算列算子中的使用：

1. 首先注册自定义函数
2. 首先对一个算子来说，每个字段都有自己的表达式（N个字段）。
   1. 每个计算表达式(如果不为空)将会解析成一个 <表达式，表达式中包含的变量>的Entry，放到paramsMap中
3. 然后计算列接收M行数据（M个Row），对每一个Row，执行一次calculate方法，然后执行N次calculateSingleColumn，结果按照顺序存放到Object[] resultValues中，最后生成一个结果Row对象
   1. 获取目标字段在结果Row中的序号
   2. 如果这个字段的表达式为空，那么直接从输入的Row取出来放进去resultValues
   3. 如果表达式不为空
      1. 首先解析编译表达式，目的是找到生成一个Function
      2. 然后获取参数列表
      3. 通过参数列表将参数的值从输入Row中取出来准备好
      4. calculateByExpression （Expression, 参数和值的映射，目标类型）
      5. 利用aviator的能力计算出值（前提是功能要都支持）
      6. 转换类型并返回



原：注册自定义函数-》表达式字符串-》Expression对象-》通过表达式字符串获取参数列表-》填充参数列表的值-》expression.execute-》类型转换

新：创建ExpressRunner对象并添加自定义函数-》通过表达式字符串获取参数列表-》填充参数列表的值-》runner.execute-》类型转换



### QLExpress

**ExpressRunner的几个构造方法的参数解析(❤ ω ❤)**

- isPrecise：这个参数可以能够让我们专注公式，而不需要关注数据精度问题，基本四则运算的结果是BigDecimal对象
- aExpressResourceLoader：QL默认实现了表达式加载器，应该是可以加载表达式文件 xxx.ql进来

**ExpressRunner.execute的几个重载\(￣︶￣*\))**

- isCache：一个表达式多次被执行，除了第一次以外，后面执行会使用第一次的结果，但是如果你一个表达式每次的上下文都不一样那就没有加速的效果了。

**向runner里面添加自定义函数**

- 继承Operator并实现`executeInner(Object[] list) `,使用方法是 FunctionName(arg0, arg1, arg2, …)

- `runner.addFunction(FunctionName, new T() extend Operator)`

- 自定义函数和操作符不能被重复添加到同一个runner中，会抛出异常，可以通过`getFunction()` 查询自定义的函数或操作符（没有getOperator）

- 绑定一个自定义函数到**某个对象**的某个方法中

  ```shell
  1. 首先我们有这样一个实例方法
  	public String writeName(String name){
     	 	String result = "MyNameIs:" + name;
      	return result;
  	}
  2. 注册：
  	runner.addFunctionOfServiceMethod("write", new Student(), "writeName",new String[] { "String" }, null);
  	参数1：在表达式中的函数名
  	参数2：绑定到哪个类里面
      参数3：目标类的方法名
  	参数4：目标类方法的参数列表（与参数3确定一个签名）
  3. 使用
  	"list = write(huang)"
  ```

- 绑定一个自定义函数到**某个类**的某个方法中

  - 区别在于这个方法需要是静态方法，因为不会给你new这个类的对象出来

**向runner添加自定义操作符**

- 继承Operator并实现`executeInner(Object[] list)`，使用方法是 `arg0 FunctionName arg1 FunctionName arg2`，只能实现二元操作符（？）

- `runner.addOperator(FunctionName, new T() extend Operator)`，如果添加为操作符了，就不能按照函数的用法了。

- 同样你可以重写系统操作符

  > runner.replaceOperator("+",new JoinOperator());



**一些骚操作**

- 如果我们在表达式中有赋值操作，那么计算结果将会被保存到context上下文中，后续的表达式可以访问到这个变量。

